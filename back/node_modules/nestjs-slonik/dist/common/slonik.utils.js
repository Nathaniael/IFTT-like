"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateString = exports.handleRetry = exports.getPoolToken = exports.getPoolName = void 0;
const common_1 = require("@nestjs/common");
const uuid_1 = require("uuid");
const operators_1 = require("rxjs/operators");
const slonik_constants_1 = require("../slonik.constants");
const logger = new common_1.Logger('SlonikModule');
function getPoolName(options) {
    return options && options.name ? options.name : slonik_constants_1.DEFAULT_POOL_NAME;
}
exports.getPoolName = getPoolName;
function getPoolToken(options = slonik_constants_1.DEFAULT_POOL_NAME) {
    const name = typeof options === 'string' ? options : getPoolName(options);
    return `${name}SlonikPool`;
}
exports.getPoolToken = getPoolToken;
function handleRetry(retryAttempts = 9, retryDelay = 3000, poolName = slonik_constants_1.DEFAULT_POOL_NAME, verboseRetryLog = false, toRetry) {
    return (source) => source.pipe(operators_1.retryWhen((e) => e.pipe(operators_1.scan((errorCount, error) => {
        if (toRetry && !toRetry(error)) {
            throw error;
        }
        const poolInfo = poolName === slonik_constants_1.DEFAULT_POOL_NAME ? '' : ` (${poolName})`;
        const verboseMessage = verboseRetryLog
            ? ` Message: ${error.message}.`
            : '';
        logger.error(`Unable to connect to the database${poolInfo}.${verboseMessage} Retrying (${errorCount + 1})...`, error.stack);
        if (errorCount + 1 >= retryAttempts) {
            throw error;
        }
        return errorCount + 1;
    }, 0), operators_1.delay(retryDelay))));
}
exports.handleRetry = handleRetry;
const generateString = () => uuid_1.v4();
exports.generateString = generateString;
